"""
Knowledge Graph Visualization Script

This script provides multiple ways to visualize the knowledge graphs generated by PatientMap.
Run with: python visualize_graph.py <path_to_json_file>
"""

import json
import sys
import math
from pathlib import Path
import networkx as nx
import matplotlib.pyplot as plt
from matplotlib.patches import FancyBboxPatch


def load_graph(json_path: str) -> nx.DiGraph:
    """Load a knowledge graph from JSON file."""
    with open(json_path, 'r', encoding='utf-8') as f:
        data = json.load(f)
    return nx.node_link_graph(data, directed=True)


def get_node_colors(graph: nx.DiGraph) -> dict:
    """Assign colors to nodes based on their type."""
    color_map = {
        'patient': '#FF6B6B',       # Red
        'condition': '#4ECDC4',     # Teal
        'medication': '#45B7D1',    # Blue
        'symptom': '#FFA07A',       # Light Orange
        'research_article': '#98D8C8', # Mint Green
        'clinical_trial': '#95E1D3',   # Pale Green
        'treatment': '#C7CEEA',     # Lavender
        'unknown': '#CCCCCC'        # Gray
    }
    
    node_colors = []
    for node_id in graph.nodes():
        node_type = graph.nodes[node_id].get('node_type', 'unknown')
        node_colors.append(color_map.get(node_type, color_map['unknown']))
    
    return node_colors


def get_node_sizes(graph: nx.DiGraph) -> list:
    """Calculate node sizes based on degree (number of connections)."""
    sizes = []
    for node_id in graph.nodes():
        degree = graph.degree(node_id)
        # Patient node should be largest
        if graph.nodes[node_id].get('node_type') == 'patient':
            sizes.append(3000)
        else:
            # Size based on connections (min 500, max 2000)
            size = 500 + (degree * 200)
            sizes.append(min(size, 2000))
    return sizes


def visualize_hierarchical(graph: nx.DiGraph, output_path: str = None):
    """Create a hierarchical visualization with patient at the center."""
    plt.figure(figsize=(16, 12))
    
    # Find patient node
    patient_nodes = [n for n in graph.nodes() if graph.nodes[n].get('node_type') == 'patient']
    
    if patient_nodes:
        # Use hierarchical layout with patient as root
        pos = nx.spring_layout(graph, k=2, iterations=50, seed=42)
    else:
        pos = nx.spring_layout(graph, k=2, iterations=50, seed=42)
    
    # Draw edges first (so they appear behind nodes)
    nx.draw_networkx_edges(
        graph, pos,
        edge_color='#999999',
        arrows=True,
        arrowsize=20,
        arrowstyle='->',
        width=2,
        alpha=0.6,
        connectionstyle='arc3,rad=0.1'
    )
    
    # Draw edge labels
    edge_labels = {}
    for source, target in graph.edges():
        edge_data = graph.get_edge_data(source, target)
        label = edge_data.get('relationship_type', '')
        edge_labels[(source, target)] = label
    
    nx.draw_networkx_edge_labels(
        graph, pos,
        edge_labels,
        font_size=8,
        font_color='#666666'
    )
    
    # Draw nodes
    node_colors = get_node_colors(graph)
    node_sizes = get_node_sizes(graph)
    
    nx.draw_networkx_nodes(
        graph, pos,
        node_color=node_colors,
        node_size=node_sizes,
        alpha=0.9,
        edgecolors='black',
        linewidths=2
    )
    
    # Draw labels
    labels = {}
    for node_id in graph.nodes():
        label = graph.nodes[node_id].get('label', node_id)
        # Truncate long labels
        if len(label) > 30:
            label = label[:27] + '...'
        labels[node_id] = label
    
    nx.draw_networkx_labels(
        graph, pos,
        labels,
        font_size=10,
        font_weight='bold',
        font_color='black'
    )
    
    # Create legend
    legend_elements = [
        plt.scatter([], [], s=200, c='#FF6B6B', label='Patient', edgecolors='black', linewidths=2),
        plt.scatter([], [], s=200, c='#4ECDC4', label='Condition', edgecolors='black', linewidths=2),
        plt.scatter([], [], s=200, c='#45B7D1', label='Medication', edgecolors='black', linewidths=2),
        plt.scatter([], [], s=200, c='#FFA07A', label='Symptom', edgecolors='black', linewidths=2),
        plt.scatter([], [], s=200, c='#98D8C8', label='Research', edgecolors='black', linewidths=2),
        plt.scatter([], [], s=200, c='#95E1D3', label='Clinical Trial', edgecolors='black', linewidths=2),
    ]
    plt.legend(handles=legend_elements, loc='upper right', fontsize=10)
    
    plt.title('Patient Knowledge Graph - Hierarchical View', fontsize=16, fontweight='bold', pad=20)
    plt.axis('off')
    plt.tight_layout()
    
    if output_path:
        plt.savefig(output_path, dpi=300, bbox_inches='tight', facecolor='white')
        print(f"Saved visualization to: {output_path}")
    
    plt.show()


def visualize_circular(graph: nx.DiGraph, output_path: str = None):
    """Create a circular visualization with patient at center."""
    plt.figure(figsize=(16, 12))
    
    # Find patient node for centering
    patient_nodes = [n for n in graph.nodes() if graph.nodes[n].get('node_type') == 'patient']
    
    if patient_nodes:
        # Create circular layout with patient at center
        patient_id = patient_nodes[0]
        other_nodes = [n for n in graph.nodes() if n != patient_id]
        
        # Patient at center
        pos = {patient_id: (0, 0)}
        
        # Other nodes in concentric circles based on distance from patient
        for i, node in enumerate(other_nodes):
            angle = (2 * math.pi * i) / len(other_nodes)
            radius = 2
            pos[node] = (radius * math.cos(angle), radius * math.sin(angle))
    else:
        pos = nx.circular_layout(graph)
    
    # Draw edges
    nx.draw_networkx_edges(
        graph, pos,
        edge_color='#999999',
        arrows=True,
        arrowsize=20,
        arrowstyle='->',
        width=2,
        alpha=0.6,
        connectionstyle='arc3,rad=0.1'
    )
    
    # Draw nodes
    node_colors = get_node_colors(graph)
    node_sizes = get_node_sizes(graph)
    
    nx.draw_networkx_nodes(
        graph, pos,
        node_color=node_colors,
        node_size=node_sizes,
        alpha=0.9,
        edgecolors='black',
        linewidths=2
    )
    
    # Draw labels
    labels = {node_id: graph.nodes[node_id].get('label', node_id) for node_id in graph.nodes()}
    nx.draw_networkx_labels(
        graph, pos,
        labels,
        font_size=10,
        font_weight='bold'
    )
    
    plt.title('Patient Knowledge Graph - Circular View', fontsize=16, fontweight='bold', pad=20)
    plt.axis('off')
    plt.tight_layout()
    
    if output_path:
        plt.savefig(output_path, dpi=300, bbox_inches='tight', facecolor='white')
        print(f"Saved visualization to: {output_path}")
    
    plt.show()


def print_graph_stats(graph: nx.DiGraph):
    """Print statistics about the knowledge graph."""
    print("\n" + "="*80)
    print("KNOWLEDGE GRAPH STATISTICS")
    print("="*80)
    
    # Find patient
    patient_nodes = [n for n in graph.nodes() if graph.nodes[n].get('node_type') == 'patient']
    if patient_nodes:
        patient_id = patient_nodes[0]
        patient_name = graph.nodes[patient_id].get('name', patient_id)
        print(f"\nPatient: {patient_name}")
        print(f"Patient ID: {patient_id}")
    
    # Node statistics
    print(f"\nTotal Nodes: {graph.number_of_nodes()}")
    print(f"Total Edges: {graph.number_of_edges()}")
    
    # Nodes by type
    node_types = {}
    for node_id in graph.nodes():
        ntype = graph.nodes[node_id].get('node_type', 'unknown')
        node_types[ntype] = node_types.get(ntype, 0) + 1
    
    print("\nNodes by Type:")
    for ntype, count in sorted(node_types.items()):
        print(f"  {ntype}: {count}")
    
    # Relationship types
    rel_types = {}
    for source, target in graph.edges():
        edge_data = graph.get_edge_data(source, target)
        rtype = edge_data.get('relationship_type', 'unknown')
        rel_types[rtype] = rel_types.get(rtype, 0) + 1
    
    print("\nRelationships by Type:")
    for rtype, count in sorted(rel_types.items()):
        print(f"  {rtype}: {count}")
    
    print("\n" + "="*80 + "\n")


def main():
    """Main function to run visualization."""
    if len(sys.argv) < 2:
        print("Usage: python visualize_graph.py <path_to_json_file> [--circular]")
        print("\nExample:")
        print("  python visualize_graph.py Darren_KG_20251110_194555.json")
        print("  python visualize_graph.py Darren_KG_20251110_194555.json --circular")
        sys.exit(1)
    
    json_path = Path(sys.argv[1])
    
    if not json_path.exists():
        print(f"Error: File not found: {json_path}")
        sys.exit(1)
    
    print(f"Loading knowledge graph from: {json_path}")
    graph = load_graph(str(json_path))
    
    # Print statistics
    print_graph_stats(graph)
    
    # Generate output path for saved image
    output_path = json_path.parent / f"{json_path.stem}_visualization.png"
    
    # Choose visualization style
    if '--circular' in sys.argv:
        print("Creating circular visualization...")
        visualize_circular(graph, str(output_path))
    else:
        print("Creating hierarchical visualization...")
        visualize_hierarchical(graph, str(output_path))
    
    print("\nVisualization complete!")


if __name__ == "__main__":
    main()
